# 1. Исследование структуры пакета
## а. Дополните схему дерева файлов и модулей пакета calculator, указав, какие модули и функции в них содержатся.
```
calculator/
├── __init__.py
├── basic/
│   ├── __init__.py
│   ├── addition.py
    ├── multiplication.py
│   └── subtraction.py
└── advanced/
    ├──trygonometry/
       ├── __init__.py
       ├── sine.py
       ├── cosine.py
       └── tangent.py
    ├── __init__.py
    ├── exponentiation.py
    └── root.py
```
## б. Объясните, какую роль играют файлы `__init__.py` в каждом каталоге пакета. Почему без них пакет не будет работать правильно?

`__init__.py` — специальный файл, который обозначает каталог как пакет. Он может быть пустым или содержать код инициализации пакета. Наличие этого файла в пакете сокращает текст для import в main.py. Так же при использовании функции не придется прописывать название_пакета.модуль.имя_функции.
1) Инициализация пакета. Код, который нужно выполнить при импортировании модулей из пакета, можно поместить в `__init__.py`.

2) Определение пакета. Наличие `__init__.py` говорит Python, что директория является пакетом, даже если он пуст.

# 2. Работа с `__init__.py`
## а. Обратите внимание на использование переменной `__all__` в файле `calculator/__init__.py`. Объясните, как она влияет на импорт пакета.

`__all__` — это список, который содержит имена всех объектов, доступных для импорта при использовании конструкции from mymodule import *. Будут импортированы только функции, указанные с списке `__all__`, остальные функции или объекты останутся недоступными.

## б. Удалите или закомментируйте строку `__all__ = ["basic", "advanced"]` в файле `calculator/__init__.py`. Попробуйте импортировать пакет снова:
```
from calculator import basic
```
### Что произошло? Объясните причину возникшей проблемы.

Среда разработки сообщает об ошибке:
Доступ к "basic" не осуществляется
Так как нет списка `__all__`, то модули basic, advanced являются "приватными" и недоступны для импорта.
Если импортировать объекты напрямую, например, `from mymodule import _private_function`, то `__all__` будет проигнорирован.

## в. Верните строку `__all__` обратно. Попробуйте выполнить команду:
```from calculator import *```
### Какие модули будут импортированы? Как можно управлять импортируемыми модулями с помощью __all__?

Будут импортированы модули advanced и basic, указанные в `__all__`
Если `__all__` определен в модуле, то from module import * импортирует только те имена, которые перечислены в `__all__`.
Если `__all__` не определен, то from module import * по умолчанию импортирует все имена, которые не начинаются с символа подчеркивания `_`.

# 3. Абсолютный и относительный импорт
## а. В файле calculator/basic/__init__.py замените относительные импорты на абсолютные:

```
from calculator.basic.addition import add
from calculator.basic.subtraction import subtract
```
### Проверьте работоспособность пакета. Объясните разницу между относительным и абсолютным импортом. Какие преимущества и недостатки каждого из них?

Абсолютный импорт использует полный путь к модулю относительно корневого пакета. Он ясен и понятен, но может быть неудобен при изменении структуры пакетов.

Относительный импорт позволяет импортировать модули относительно текущего местоположения, используя точки.
Преимущества относительного импорта:
Упрощает импорт внутри пакета.
Легче поддерживать при реорганизации пакетов. НО относительный импорт возможен только внутри пакетов, в отличие от абсолютного импорта.

## б. Предположим, что структура пакета изменилась, и папка basic была переименована в simple. Объясните, как это повлияет на абсолютные и относительные импорты. Какой импорт легче поддерживать при реорганизации структуры пакета?

Относительные импорты поддерживать проще при реорганизации, так как в них не указывается вся иерархия пакета с названиями подпапок - указывается только целевая папка через n-ое количество точек и нужный объект. Например, from .addition import add - мы не указали новое имя пакета - simple
При абсолютных импортах переименование папки из basic в simple сломает эти импорты, так сатрое имя не будет существовать.

# 4. Добавление новых модулей
## а. Добавьте в пакет calculator/basic новый модуль multiplication.py с функцией multiply(a, b), которая возвращает произведение a и b.
```
def multiply(a, b):
    return a*b
```
## б. Обновите файл `calculator/basic/__init__.py`, чтобы функция multiply была доступна при импорте пакета.
```
from .multiplication import multiply
```
## в. В файле main.py импортируйте новую функцию и протестируйте ее.
```
from calculator.basic import multiply
print(multiply(4, 5))        # Вывод: 20
```
```
from calculator.basic import add, subtract, multiply
print(multiply(4, 5))
```
# 5. Исследование переменной `__name__`
## а. В файле calculator/advanced/exponentiation.py добавьте следующий код:
```
if __name__ == "__main__":
    print(power(2, 5))
```
## б. Запустите файл exponentiation.py напрямую. Что произошло? Какой вывод вы получили?

При запуске файла exponentiation.py напрямую программа вывела результат функции power --> 32

## в. Импортируйте функцию power в main.py и запустите main.py. Выполняется ли код внутри блока `if __name__ == "__main__"`: в файле exponentiation.py при импорте? Объясните, почему.

Нет, код внутри блока `if __name__ == "__main__"`: в файле exponentiation.py при импорте НЕ выполняется. Потому что модуль был запущен из другой точки программы (main.py).
Когда модуль запускается как основной файл программы, `__name__` принимает значение `__main__`. Это позволяет определять точку входа в программу. Используется при тестировании модуля без запуска в main.

# 6. Изучение путей поиска модулей
## а. Выведите переменную sys.path в main.py:
```
import sys
print(sys.path)
```
### Объясните, какие пути в ней содержатся и как Python использует их для поиска модулей.

['c:\\Users\\rst\\Documents\\МИИГАиК\\Python VS CODE projects\\Calculator project'- текущая директория из которой запущен скрипт,
'C:\\Users\\rst\\AppData\\Local\\Programs\\Python\\Python310\\python310.zip'-дикертории в переменной окружения PYTHONPATH (изменяется по желанию) ---- (*),
'C:\\Users\\rst\\AppData\\Local\\Programs\\Python\\Python310\\DLLs' --- (*),
'C:\\Users\\rst\\AppData\\Local\\Programs\\Python\\Python310\\lib' ---(*),
'C:\\Users\\rst\\AppData\\Local\\Programs\\Python\\Python310' --- (*),
'C:\\Users\\rst\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages' - стандартные директории с пакетами Python]

1) Проверка встроенных модулей: Python сначала проверяет, является ли модуль встроенным. Встроенные модули — это те, которые поставляются вместе с интерпретатором Python, такие как sys или os.

2) Поиск в sys.path: Если модуль не встроенный, Python ищет его в списке директорий, указанных в переменной sys.path. Этот список включает:
Текущую директорию, из которой был запущен скрипт.
Директории, указанные в переменной окружения PYTHONPATH.
Стандартные директории, в которых установлены пакеты Python, такие как site-packages.
3) Файлы и каталоги: Python ищет файлы с расширением .py для модулей и каталоги с файлом `__init__.py` для пакетов. Если файл или каталог найден, он загружается и выполняется.

## б. Попробуйте переместить папку calculator в другую директорию, которая не входит в sys.path. Можете ли вы теперь импортировать пакет? Что нужно сделать, чтобы Python мог найти ваш пакет?

Нужно изменить sys.path в коде: добавить новый путь в sys.path прямо в скрипте.
Например: `import sys sys.path.append('/path/to/your/module/calculator')`

# 7. Создание подпакетов
## а. Внутри calculator/advanced создайте подпакет trigonometry с функциями sin, cos и tan. Структура должна выглядеть так:
```
calculator/
└── advanced/
    ├── trigonometry/
    │   ├── __init__.py
    │   ├── sine.py
    │   ├── cosine.py
    │   └── tangent.py
```
## б. Реализуйте функции в соответствующих модулях, используя модуль math из стандартной библиотеки Python.

## в. Обновите `__init__.py` файлы, чтобы обеспечить корректный импорт функций.

## г. Импортируйте функции в main.py и протестируйте их.

# 8. Практика с относительным импортом
## а. В файле calculator/advanced/trigonometry/sine.py попробуйте импортировать функцию square_root из модуля root.py двумя способами:

Используя относительный импорт.
Используя абсолютный импорт.
## б. Объясните, какой способ импорта сработал, а какой нет, и почему.

Абсолютный импорт сработал, относительный - нет, потому что,
когда мы запускаем какой-либо файл, для Python нет ничего выше этого ЗАПУЩЕННОГО файла. Т.е. запущенный файл является корнем, и мы не сможем при импорте подняться выше него, даже если там будут какие-то другие модули/пакеты. Мы можем импортировать в ЗАПУЩЕННЫЙ файл (у которого `__name__ == "__main__"`) только пакеты и модули, находящиеся на одном уровне с ним или ниже.

# 9. Публикация на GitHub
После завершения всех заданий добавьте папку с проектом в Ваш локальный Git-репозиторий. Затем опубликуйте его на GitHub, создав приватный репозиторий.

Вопросы и Ваши ответы на них разместите в файле README.md Вашего приватного репозитория. Используйте стиль разметки Markdown. Для примеров можно обратиться к следующим ресурсам: Markdown и Readme.md.

Далее выполните следующие шаги:

Перейдите в настройки вашего репозитория:
Откройте ваш новый приватный репозиторий.
Нажмите на вкладку Settings (Настройки) в верхней части страницы.
Добавьте коллаборатора:
В меню слева выберите Collaborators (Коллабораторы).
Нажмите Add people (Добавить человека).
Введите имя пользователя GitHub: Alexandre77777.
Нажмите Add Alexandre77777 to this repository (Добавить коллаборатора).
Отправьте приглашение:
Человек, которого вы пригласили, получит уведомление на GitHub и по электронной почте.
Он должен будет принять приглашение, чтобы получить доступ к вашему репозиторию.
# Ожидаемые результаты
Вы глубоко разберетесь в структуре пакета calculator и поймете, как организованы модули и функции внутри него.
Научитесь использовать и настраивать файлы `__init__.py` для управления импортом модулей и функций.
Будете уверенно использовать как абсолютный, так и относительный импорт, понимая их разницу и области применения.
Узнаете, как переменная `__name__` влияет на выполнение кода при импорте модулей.
Поймете, как Python ищет модули и пакеты, и как управлять путями поиска.
Сможете расширять пакеты, добавляя новые модули, функции и подпакеты.
Получите практический опыт работы с пакетами, что упростит разработку больших проектов в будущем.
# Дополнительные задания (для продвинутых, не обязательны к выполнению)
1. Создание установочного скрипта

Создайте файл setup.py для вашего пакета calculator, чтобы его можно было установить с помощью pip install ..

2. Документация пакета

Добавьте документацию в ваш пакет, используя файлы README.md и строки документирования (docstrings) в функциях.

Советы по выполнению работы
Постепенно выполняйте задания, проверяя работоспособность после каждого шага.
Обращайтесь к официальной документации Python по модулям и пакетам для дополнительной информации.
